// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: initia/move/v1/types.proto

package types

import (
	bytes "bytes"
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UpgradePolicy is the policy for upgrading a move module.
type UpgradePolicy int32

const (
	// UNSPECIFIED: a placeholder for an unspecified upgrade policy.
	UpgradePolicy_UNSPECIFIED UpgradePolicy = 0
	// COMPATBILE: Whether a compatibility check should be performed for upgrades. The check only passes if
	// a new module has (a) the same public functions (b) for existing resources, no layout change.
	UpgradePolicy_COMPATIBLE UpgradePolicy = 1
	// IMMUTABLE: Whether the modules in the package are immutable and cannot be upgraded.
	UpgradePolicy_IMMUTABLE UpgradePolicy = 2
)

var UpgradePolicy_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "COMPATIBLE",
	2: "IMMUTABLE",
}

var UpgradePolicy_value = map[string]int32{
	"UNSPECIFIED": 0,
	"COMPATIBLE":  1,
	"IMMUTABLE":   2,
}

func (x UpgradePolicy) String() string {
	return proto.EnumName(UpgradePolicy_name, int32(x))
}

func (UpgradePolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{0}
}

// Params defines the set of move parameters.
type Params struct {
	BaseDenom       string                      `protobuf:"bytes,1,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	BaseMinGasPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=base_min_gas_price,json=baseMinGasPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"base_min_gas_price" yaml:"base_min_gas_price"`
	// CSR: Percentage of fees distributed to developers
	ContractSharedRevenueRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=contract_shared_revenue_ratio,json=contractSharedRevenueRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"contract_shared_revenue_ratio" yaml:"contract_shared_revenue_ratio"`
	// flag whether to enable script execution
	ScriptEnabled bool `protobuf:"varint,4,opt,name=script_enabled,json=scriptEnabled,proto3" json:"script_enabled,omitempty"`
	// It is a list of addresses with permission to distribute contracts,
	// and an empty list is interpreted as allowing anyone to distribute.
	AllowedPublishers []string `protobuf:"bytes,5,rep,name=allowed_publishers,json=allowedPublishers,proto3" json:"allowed_publishers,omitempty" yaml:"allowed_publishers"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

// RawParams defines the raw params to store.
type RawParams struct {
	BaseDenom       string                      `protobuf:"bytes,1,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	BaseMinGasPrice cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=base_min_gas_price,json=baseMinGasPrice,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"base_min_gas_price" yaml:"base_min_gas_price"`
	// CSR: Percentage of fees distributed to developers
	ContractSharedRevenueRatio cosmossdk_io_math.LegacyDec `protobuf:"bytes,3,opt,name=contract_shared_revenue_ratio,json=contractSharedRevenueRatio,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"contract_shared_revenue_ratio" yaml:"contract_shared_revenue_ratio"`
	// flag whether to enable script execution
	ScriptEnabled bool `protobuf:"varint,4,opt,name=script_enabled,json=scriptEnabled,proto3" json:"script_enabled,omitempty"`
}

func (m *RawParams) Reset()         { *m = RawParams{} }
func (m *RawParams) String() string { return proto.CompactTextString(m) }
func (*RawParams) ProtoMessage()    {}
func (*RawParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{1}
}
func (m *RawParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawParams.Merge(m, src)
}
func (m *RawParams) XXX_Size() int {
	return m.Size()
}
func (m *RawParams) XXX_DiscardUnknown() {
	xxx_messageInfo_RawParams.DiscardUnknown(m)
}

var xxx_messageInfo_RawParams proto.InternalMessageInfo

// Module is data for the uploaded contract move code
type Module struct {
	Address       string        `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	ModuleName    string        `protobuf:"bytes,2,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	Abi           string        `protobuf:"bytes,3,opt,name=abi,proto3" json:"abi,omitempty"`
	RawBytes      []byte        `protobuf:"bytes,4,opt,name=raw_bytes,json=rawBytes,proto3" json:"raw_bytes,omitempty"`
	UpgradePolicy UpgradePolicy `protobuf:"varint,5,opt,name=upgrade_policy,json=upgradePolicy,proto3,enum=initia.move.v1.UpgradePolicy" json:"upgrade_policy,omitempty"`
}

func (m *Module) Reset()         { *m = Module{} }
func (m *Module) String() string { return proto.CompactTextString(m) }
func (*Module) ProtoMessage()    {}
func (*Module) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{2}
}
func (m *Module) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Module) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Module.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Module) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Module.Merge(m, src)
}
func (m *Module) XXX_Size() int {
	return m.Size()
}
func (m *Module) XXX_DiscardUnknown() {
	xxx_messageInfo_Module.DiscardUnknown(m)
}

var xxx_messageInfo_Module proto.InternalMessageInfo

// Checksum is checksum of the uploaded contract move code
type Checksum struct {
	Address    string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	ModuleName string `protobuf:"bytes,2,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	Checksum   []byte `protobuf:"bytes,3,opt,name=checksum,proto3" json:"checksum,omitempty"`
}

func (m *Checksum) Reset()         { *m = Checksum{} }
func (m *Checksum) String() string { return proto.CompactTextString(m) }
func (*Checksum) ProtoMessage()    {}
func (*Checksum) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{3}
}
func (m *Checksum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Checksum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Checksum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Checksum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Checksum.Merge(m, src)
}
func (m *Checksum) XXX_Size() int {
	return m.Size()
}
func (m *Checksum) XXX_DiscardUnknown() {
	xxx_messageInfo_Checksum.DiscardUnknown(m)
}

var xxx_messageInfo_Checksum proto.InternalMessageInfo

// Resource is data for the stored move resource
type Resource struct {
	Address      string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	StructTag    string `protobuf:"bytes,2,opt,name=struct_tag,json=structTag,proto3" json:"struct_tag,omitempty"`
	MoveResource string `protobuf:"bytes,3,opt,name=move_resource,json=moveResource,proto3" json:"move_resource,omitempty"`
	RawBytes     []byte `protobuf:"bytes,4,opt,name=raw_bytes,json=rawBytes,proto3" json:"raw_bytes,omitempty"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{4}
}
func (m *Resource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return m.Size()
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

// TableInfo is data stored under Table address
type TableInfo struct {
	Address   string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	KeyType   string `protobuf:"bytes,2,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	ValueType string `protobuf:"bytes,3,opt,name=value_type,json=valueType,proto3" json:"value_type,omitempty"`
}

func (m *TableInfo) Reset()         { *m = TableInfo{} }
func (m *TableInfo) String() string { return proto.CompactTextString(m) }
func (*TableInfo) ProtoMessage()    {}
func (*TableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{5}
}
func (m *TableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableInfo.Merge(m, src)
}
func (m *TableInfo) XXX_Size() int {
	return m.Size()
}
func (m *TableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableInfo proto.InternalMessageInfo

// TableEntry is data stored under Table address and the key bytes
type TableEntry struct {
	Address    string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Key        string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value      string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	KeyBytes   []byte `protobuf:"bytes,4,opt,name=key_bytes,json=keyBytes,proto3" json:"key_bytes,omitempty"`
	ValueBytes []byte `protobuf:"bytes,5,opt,name=value_bytes,json=valueBytes,proto3" json:"value_bytes,omitempty"`
}

func (m *TableEntry) Reset()         { *m = TableEntry{} }
func (m *TableEntry) String() string { return proto.CompactTextString(m) }
func (*TableEntry) ProtoMessage()    {}
func (*TableEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{6}
}
func (m *TableEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableEntry.Merge(m, src)
}
func (m *TableEntry) XXX_Size() int {
	return m.Size()
}
func (m *TableEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_TableEntry.DiscardUnknown(m)
}

var xxx_messageInfo_TableEntry proto.InternalMessageInfo

// proto wrapper to store the value
type UpgradePolicyProto struct {
	Policy UpgradePolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=initia.move.v1.UpgradePolicy" json:"policy,omitempty"`
}

func (m *UpgradePolicyProto) Reset()         { *m = UpgradePolicyProto{} }
func (m *UpgradePolicyProto) String() string { return proto.CompactTextString(m) }
func (*UpgradePolicyProto) ProtoMessage()    {}
func (*UpgradePolicyProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{7}
}
func (m *UpgradePolicyProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradePolicyProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradePolicyProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradePolicyProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradePolicyProto.Merge(m, src)
}
func (m *UpgradePolicyProto) XXX_Size() int {
	return m.Size()
}
func (m *UpgradePolicyProto) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradePolicyProto.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradePolicyProto proto.InternalMessageInfo

// DexPair contains coin metdata address
// std::dex::Pool and std::dex::Config resources.
type DexPair struct {
	MetadataQuote string `protobuf:"bytes,1,opt,name=metadata_quote,json=metadataQuote,proto3" json:"metadata_quote,omitempty"`
	MetadataLP    string `protobuf:"bytes,2,opt,name=metadata_lp,json=metadataLp,proto3" json:"metadata_lp,omitempty"`
}

func (m *DexPair) Reset()         { *m = DexPair{} }
func (m *DexPair) String() string { return proto.CompactTextString(m) }
func (*DexPair) ProtoMessage()    {}
func (*DexPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{8}
}
func (m *DexPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DexPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DexPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DexPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DexPair.Merge(m, src)
}
func (m *DexPair) XXX_Size() int {
	return m.Size()
}
func (m *DexPair) XXX_DiscardUnknown() {
	xxx_messageInfo_DexPair.DiscardUnknown(m)
}

var xxx_messageInfo_DexPair proto.InternalMessageInfo

// ExecuteAuthorizationItem is the information for granting module execution
type ExecuteAuthorizationItem struct {
	// ModuleAddr is the address of the module deployer
	ModuleAddress string `protobuf:"bytes,1,opt,name=module_address,json=moduleAddress,proto3" json:"module_address,omitempty"`
	// ModuleName is the names of module to execute
	ModuleName string `protobuf:"bytes,2,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	// FunctionName is the name of function to execute with wildcard '*' support
	FunctionNames []string `protobuf:"bytes,3,rep,name=function_names,json=functionNames,proto3" json:"function_names,omitempty"`
}

func (m *ExecuteAuthorizationItem) Reset()         { *m = ExecuteAuthorizationItem{} }
func (m *ExecuteAuthorizationItem) String() string { return proto.CompactTextString(m) }
func (*ExecuteAuthorizationItem) ProtoMessage()    {}
func (*ExecuteAuthorizationItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{9}
}
func (m *ExecuteAuthorizationItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteAuthorizationItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteAuthorizationItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteAuthorizationItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteAuthorizationItem.Merge(m, src)
}
func (m *ExecuteAuthorizationItem) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteAuthorizationItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteAuthorizationItem.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteAuthorizationItem proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("initia.move.v1.UpgradePolicy", UpgradePolicy_name, UpgradePolicy_value)
	proto.RegisterType((*Params)(nil), "initia.move.v1.Params")
	proto.RegisterType((*RawParams)(nil), "initia.move.v1.RawParams")
	proto.RegisterType((*Module)(nil), "initia.move.v1.Module")
	proto.RegisterType((*Checksum)(nil), "initia.move.v1.Checksum")
	proto.RegisterType((*Resource)(nil), "initia.move.v1.Resource")
	proto.RegisterType((*TableInfo)(nil), "initia.move.v1.TableInfo")
	proto.RegisterType((*TableEntry)(nil), "initia.move.v1.TableEntry")
	proto.RegisterType((*UpgradePolicyProto)(nil), "initia.move.v1.UpgradePolicyProto")
	proto.RegisterType((*DexPair)(nil), "initia.move.v1.DexPair")
	proto.RegisterType((*ExecuteAuthorizationItem)(nil), "initia.move.v1.ExecuteAuthorizationItem")
}

func init() { proto.RegisterFile("initia/move/v1/types.proto", fileDescriptor_5ab4b0783858a3a5) }

var fileDescriptor_5ab4b0783858a3a5 = []byte{
	// 894 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x55, 0xbf, 0x6f, 0x23, 0x45,
	0x14, 0xf6, 0xc6, 0x97, 0xc4, 0x7e, 0x8e, 0x7d, 0xb9, 0xd1, 0x15, 0x7b, 0x3e, 0xc5, 0x8e, 0x16,
	0x90, 0xa2, 0x20, 0x6c, 0x1d, 0x88, 0xe6, 0x1a, 0x14, 0xc7, 0x06, 0x59, 0xd8, 0xc7, 0xde, 0x9e,
	0xd3, 0xd0, 0xac, 0xc6, 0xbb, 0x73, 0xf6, 0xca, 0xbb, 0x3b, 0xcb, 0xcc, 0xac, 0x93, 0xa5, 0xa7,
	0x41, 0x48, 0x20, 0xd1, 0x50, 0x5e, 0x79, 0xe5, 0x95, 0xfc, 0x03, 0x48, 0x29, 0xaf, 0x44, 0x20,
	0x59, 0xe0, 0x14, 0x47, 0xcd, 0x5f, 0x80, 0x66, 0x66, 0x1d, 0xb0, 0x22, 0x59, 0x91, 0x10, 0x1d,
	0xcd, 0x6a, 0xde, 0xf7, 0x7d, 0x7a, 0xbf, 0x77, 0x06, 0xea, 0x41, 0x1c, 0x88, 0x00, 0xb7, 0x23,
	0x3a, 0x27, 0xed, 0xf9, 0xa3, 0xb6, 0xc8, 0x12, 0xc2, 0x5b, 0x09, 0xa3, 0x82, 0xa2, 0x9a, 0xe6,
	0x5a, 0x92, 0x6b, 0xcd, 0x1f, 0xd5, 0xef, 0xe1, 0x28, 0x88, 0x69, 0x5b, 0x7d, 0xb5, 0xa4, 0x7e,
	0x7f, 0x42, 0x27, 0x54, 0x1d, 0xdb, 0xf2, 0xa4, 0x51, 0xeb, 0xa7, 0x22, 0xec, 0xd8, 0x98, 0xe1,
	0x88, 0xa3, 0x03, 0x80, 0x31, 0xe6, 0xc4, 0xf5, 0x49, 0x4c, 0x23, 0xd3, 0x38, 0x34, 0x8e, 0xca,
	0x4e, 0x59, 0x22, 0x5d, 0x09, 0x20, 0x06, 0x48, 0xd1, 0x51, 0x10, 0xbb, 0x13, 0xcc, 0xdd, 0x84,
	0x05, 0x1e, 0x31, 0xb7, 0xa4, 0xac, 0xd3, 0xbb, 0x5c, 0x34, 0x0b, 0xbf, 0x2c, 0x9a, 0x0f, 0x3d,
	0xca, 0x23, 0xca, 0xb9, 0x3f, 0x6b, 0x05, 0xb4, 0x1d, 0x61, 0x31, 0x6d, 0x0d, 0xc8, 0x04, 0x7b,
	0x59, 0x97, 0x78, 0x7f, 0x2e, 0x9a, 0x0f, 0x32, 0x1c, 0x85, 0x8f, 0xad, 0x9b, 0x6e, 0xac, 0x97,
	0x6f, 0x5e, 0x1d, 0x1b, 0xce, 0x5d, 0xc9, 0x0c, 0x83, 0xf8, 0x13, 0xcc, 0x6d, 0x09, 0xa3, 0xef,
	0x0d, 0x38, 0xf0, 0x68, 0x2c, 0x18, 0xf6, 0x84, 0xcb, 0xa7, 0x98, 0x11, 0xdf, 0x65, 0x64, 0x4e,
	0xe2, 0x94, 0xb8, 0x0c, 0x8b, 0x80, 0x9a, 0x45, 0x15, 0xdf, 0xbe, 0x5d, 0xfc, 0xb7, 0x75, 0xfc,
	0x8d, 0x1e, 0xf3, 0x54, 0xea, 0x2b, 0xd1, 0x33, 0xa5, 0x71, 0xb4, 0xc4, 0x91, 0x0a, 0xf4, 0x0e,
	0xd4, 0xb8, 0xc7, 0x82, 0x44, 0xb8, 0x24, 0xc6, 0xe3, 0x90, 0xf8, 0xe6, 0x9d, 0x43, 0xe3, 0xa8,
	0xe4, 0x54, 0x35, 0xda, 0xd3, 0x20, 0x7a, 0x0a, 0x08, 0x87, 0x21, 0x3d, 0x27, 0xbe, 0x9b, 0xa4,
	0xe3, 0x30, 0xe0, 0x53, 0xc2, 0xb8, 0xb9, 0x7d, 0x58, 0x3c, 0x2a, 0x77, 0xac, 0xbf, 0xbb, 0x71,
	0x53, 0x93, 0xa7, 0x70, 0x2f, 0x67, 0xec, 0x6b, 0xe2, 0xb1, 0xf9, 0xc3, 0x8b, 0x66, 0xe1, 0x8f,
	0x17, 0x4d, 0xe3, 0xeb, 0x37, 0xaf, 0x8e, 0x2b, 0x6a, 0x11, 0xf4, 0xf0, 0xac, 0x5f, 0xb7, 0xa0,
	0xec, 0xe0, 0xf3, 0xff, 0x47, 0xf9, 0x5f, 0x8c, 0xd2, 0xfa, 0xd1, 0x80, 0x9d, 0x21, 0xf5, 0xd3,
	0x90, 0x20, 0x13, 0x76, 0xb1, 0xef, 0x33, 0xc2, 0x79, 0xde, 0xd7, 0x95, 0x89, 0x9a, 0x50, 0x89,
	0x94, 0xc6, 0x8d, 0x71, 0x94, 0xb7, 0xd3, 0x01, 0x0d, 0x3d, 0xc1, 0x11, 0x41, 0xfb, 0x50, 0xc4,
	0xe3, 0x40, 0xd7, 0xe9, 0xc8, 0x23, 0x7a, 0x08, 0x65, 0x86, 0xcf, 0xdd, 0x71, 0x26, 0x08, 0x57,
	0x91, 0xf7, 0x9c, 0x12, 0xc3, 0xe7, 0x1d, 0x69, 0xa3, 0x2e, 0xd4, 0xd2, 0x64, 0xc2, 0xb0, 0x4f,
	0xdc, 0x84, 0x86, 0x81, 0x97, 0x99, 0xdb, 0x87, 0xc6, 0x51, 0xed, 0xfd, 0x83, 0xd6, 0xfa, 0xcf,
	0xde, 0x3a, 0xd3, 0x2a, 0x5b, 0x89, 0x9c, 0x6a, 0xfa, 0x4f, 0xd3, 0xc2, 0x50, 0x3a, 0x9d, 0x12,
	0x6f, 0xc6, 0xd3, 0xe8, 0xdf, 0xe4, 0x5e, 0x87, 0x92, 0x97, 0xbb, 0x51, 0x05, 0xec, 0x39, 0xd7,
	0xb6, 0xf5, 0x95, 0x01, 0x25, 0x87, 0x70, 0x9a, 0x32, 0x6f, 0x53, 0x7f, 0x0e, 0x00, 0xb8, 0x60,
	0xa9, 0x27, 0x5c, 0x81, 0x27, 0x79, 0x88, 0xb2, 0x46, 0x46, 0x78, 0x82, 0xde, 0x82, 0xaa, 0x2c,
	0xc8, 0x65, 0xb9, 0xa7, 0xbc, 0x4f, 0x7b, 0x12, 0xbc, 0xf6, 0xbe, 0xa9, 0x61, 0x96, 0x0b, 0xe5,
	0x91, 0x9c, 0x57, 0x3f, 0x7e, 0x4e, 0x37, 0xe4, 0xf1, 0x00, 0x4a, 0x33, 0x92, 0xb9, 0xf2, 0xfa,
	0xcc, 0xb3, 0xd8, 0x9d, 0x91, 0x6c, 0x94, 0x25, 0x44, 0xa6, 0x38, 0xc7, 0x61, 0x4a, 0x34, 0xa9,
	0x13, 0x28, 0x2b, 0x44, 0xd2, 0xd6, 0x37, 0x06, 0x80, 0x8a, 0xd0, 0x8b, 0x05, 0xcb, 0x36, 0x84,
	0xd8, 0x87, 0xe2, 0x8c, 0x64, 0xb9, 0x77, 0x79, 0x44, 0xf7, 0x61, 0x5b, 0xf9, 0xc9, 0x9d, 0x6a,
	0x43, 0x96, 0x23, 0x53, 0x59, 0x2b, 0x67, 0x46, 0x32, 0x3d, 0xff, 0x26, 0x54, 0x74, 0x32, 0x9a,
	0xde, 0x56, 0xb4, 0xce, 0x4f, 0xd7, 0xfb, 0x29, 0xa0, 0xb5, 0xd1, 0xdb, 0xea, 0x29, 0xf8, 0x10,
	0x76, 0xf2, 0x75, 0x31, 0x6e, 0xb3, 0x2e, 0xb9, 0xd8, 0xc2, 0xb0, 0xdb, 0x25, 0x17, 0x36, 0x0e,
	0x98, 0xfc, 0x29, 0x22, 0x22, 0xb0, 0x8f, 0x05, 0x76, 0xbf, 0x48, 0xa9, 0x20, 0x79, 0x79, 0xd5,
	0x15, 0xfa, 0x54, 0x82, 0xa8, 0x0d, 0x95, 0x6b, 0x59, 0x98, 0xe4, 0xd7, 0x47, 0x6d, 0xb9, 0x68,
	0xc2, 0x30, 0x87, 0x07, 0xb6, 0x03, 0x2b, 0xc9, 0x20, 0xb1, 0xbe, 0x35, 0xc0, 0xec, 0x5d, 0x10,
	0x2f, 0x15, 0xe4, 0x24, 0x15, 0x53, 0xca, 0x82, 0x2f, 0xe5, 0x4f, 0x18, 0xf7, 0x05, 0x89, 0x54,
	0x50, 0xbd, 0x81, 0xeb, 0x3d, 0xad, 0x6a, 0xf4, 0xe4, 0xb6, 0x8b, 0xfa, 0x2e, 0xd4, 0x9e, 0xa7,
	0xb1, 0x27, 0xfd, 0x2a, 0x09, 0x37, 0x8b, 0xea, 0xc6, 0xbd, 0x73, 0xb9, 0x68, 0x1a, 0x4e, 0x75,
	0xc5, 0x49, 0x2d, 0x3f, 0xfe, 0x08, 0xaa, 0x6b, 0xdd, 0x40, 0x77, 0xa1, 0x72, 0xf6, 0xe4, 0x99,
	0xdd, 0x3b, 0xed, 0x7f, 0xdc, 0xef, 0x75, 0xf7, 0x0b, 0xa8, 0x06, 0x70, 0xfa, 0xd9, 0xd0, 0x3e,
	0x19, 0xf5, 0x3b, 0x83, 0xde, 0xbe, 0x81, 0xaa, 0x50, 0xee, 0x0f, 0x87, 0x67, 0xa3, 0x13, 0x69,
	0x6e, 0x75, 0x06, 0x97, 0xbf, 0x37, 0x0a, 0x2f, 0x97, 0x0d, 0xe3, 0x72, 0xd9, 0x30, 0x5e, 0x2f,
	0x1b, 0xc6, 0x6f, 0xcb, 0x86, 0xf1, 0xdd, 0x55, 0xa3, 0xf0, 0xfa, 0xaa, 0x51, 0xf8, 0xf9, 0xaa,
	0x51, 0xf8, 0xfc, 0x78, 0x12, 0x88, 0x69, 0x3a, 0x6e, 0x79, 0x34, 0x6a, 0xeb, 0x41, 0xbc, 0x17,
	0xe2, 0x31, 0xcf, 0xcf, 0xed, 0x0b, 0xfd, 0x9c, 0xab, 0xb7, 0x7c, 0xbc, 0xa3, 0xde, 0xe4, 0x0f,
	0xfe, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x96, 0x15, 0xb1, 0x79, 0xea, 0x07, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BaseDenom != that1.BaseDenom {
		return false
	}
	if !this.BaseMinGasPrice.Equal(that1.BaseMinGasPrice) {
		return false
	}
	if !this.ContractSharedRevenueRatio.Equal(that1.ContractSharedRevenueRatio) {
		return false
	}
	if this.ScriptEnabled != that1.ScriptEnabled {
		return false
	}
	if len(this.AllowedPublishers) != len(that1.AllowedPublishers) {
		return false
	}
	for i := range this.AllowedPublishers {
		if this.AllowedPublishers[i] != that1.AllowedPublishers[i] {
			return false
		}
	}
	return true
}
func (this *RawParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawParams)
	if !ok {
		that2, ok := that.(RawParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BaseDenom != that1.BaseDenom {
		return false
	}
	if !this.BaseMinGasPrice.Equal(that1.BaseMinGasPrice) {
		return false
	}
	if !this.ContractSharedRevenueRatio.Equal(that1.ContractSharedRevenueRatio) {
		return false
	}
	if this.ScriptEnabled != that1.ScriptEnabled {
		return false
	}
	return true
}
func (this *Module) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Module)
	if !ok {
		that2, ok := that.(Module)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.ModuleName != that1.ModuleName {
		return false
	}
	if this.Abi != that1.Abi {
		return false
	}
	if !bytes.Equal(this.RawBytes, that1.RawBytes) {
		return false
	}
	if this.UpgradePolicy != that1.UpgradePolicy {
		return false
	}
	return true
}
func (this *Checksum) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Checksum)
	if !ok {
		that2, ok := that.(Checksum)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.ModuleName != that1.ModuleName {
		return false
	}
	if !bytes.Equal(this.Checksum, that1.Checksum) {
		return false
	}
	return true
}
func (this *Resource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Resource)
	if !ok {
		that2, ok := that.(Resource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.StructTag != that1.StructTag {
		return false
	}
	if this.MoveResource != that1.MoveResource {
		return false
	}
	if !bytes.Equal(this.RawBytes, that1.RawBytes) {
		return false
	}
	return true
}
func (this *TableInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableInfo)
	if !ok {
		that2, ok := that.(TableInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if this.ValueType != that1.ValueType {
		return false
	}
	return true
}
func (this *TableEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableEntry)
	if !ok {
		that2, ok := that.(TableEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !bytes.Equal(this.KeyBytes, that1.KeyBytes) {
		return false
	}
	if !bytes.Equal(this.ValueBytes, that1.ValueBytes) {
		return false
	}
	return true
}
func (this *UpgradePolicyProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpgradePolicyProto)
	if !ok {
		that2, ok := that.(UpgradePolicyProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Policy != that1.Policy {
		return false
	}
	return true
}
func (this *DexPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DexPair)
	if !ok {
		that2, ok := that.(DexPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MetadataQuote != that1.MetadataQuote {
		return false
	}
	if this.MetadataLP != that1.MetadataLP {
		return false
	}
	return true
}
func (this *ExecuteAuthorizationItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecuteAuthorizationItem)
	if !ok {
		that2, ok := that.(ExecuteAuthorizationItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ModuleAddress != that1.ModuleAddress {
		return false
	}
	if this.ModuleName != that1.ModuleName {
		return false
	}
	if len(this.FunctionNames) != len(that1.FunctionNames) {
		return false
	}
	for i := range this.FunctionNames {
		if this.FunctionNames[i] != that1.FunctionNames[i] {
			return false
		}
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllowedPublishers) > 0 {
		for iNdEx := len(m.AllowedPublishers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedPublishers[iNdEx])
			copy(dAtA[i:], m.AllowedPublishers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedPublishers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ScriptEnabled {
		i--
		if m.ScriptEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.ContractSharedRevenueRatio.Size()
		i -= size
		if _, err := m.ContractSharedRevenueRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.BaseMinGasPrice.Size()
		i -= size
		if _, err := m.BaseMinGasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScriptEnabled {
		i--
		if m.ScriptEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.ContractSharedRevenueRatio.Size()
		i -= size
		if _, err := m.ContractSharedRevenueRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.BaseMinGasPrice.Size()
		i -= size
		if _, err := m.BaseMinGasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Module) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Module) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Module) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpgradePolicy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpgradePolicy))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RawBytes) > 0 {
		i -= len(m.RawBytes)
		copy(dAtA[i:], m.RawBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RawBytes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Abi) > 0 {
		i -= len(m.Abi)
		copy(dAtA[i:], m.Abi)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Abi)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModuleName) > 0 {
		i -= len(m.ModuleName)
		copy(dAtA[i:], m.ModuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModuleName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Checksum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Checksum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Checksum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Checksum) > 0 {
		i -= len(m.Checksum)
		copy(dAtA[i:], m.Checksum)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Checksum)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModuleName) > 0 {
		i -= len(m.ModuleName)
		copy(dAtA[i:], m.ModuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModuleName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Resource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawBytes) > 0 {
		i -= len(m.RawBytes)
		copy(dAtA[i:], m.RawBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RawBytes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MoveResource) > 0 {
		i -= len(m.MoveResource)
		copy(dAtA[i:], m.MoveResource)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MoveResource)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StructTag) > 0 {
		i -= len(m.StructTag)
		copy(dAtA[i:], m.StructTag)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StructTag)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueType) > 0 {
		i -= len(m.ValueType)
		copy(dAtA[i:], m.ValueType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValueType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueBytes) > 0 {
		i -= len(m.ValueBytes)
		copy(dAtA[i:], m.ValueBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValueBytes)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyBytes) > 0 {
		i -= len(m.KeyBytes)
		copy(dAtA[i:], m.KeyBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyBytes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradePolicyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradePolicyProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradePolicyProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DexPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DexPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DexPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetadataLP) > 0 {
		i -= len(m.MetadataLP)
		copy(dAtA[i:], m.MetadataLP)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MetadataLP)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetadataQuote) > 0 {
		i -= len(m.MetadataQuote)
		copy(dAtA[i:], m.MetadataQuote)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MetadataQuote)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteAuthorizationItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteAuthorizationItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteAuthorizationItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FunctionNames) > 0 {
		for iNdEx := len(m.FunctionNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FunctionNames[iNdEx])
			copy(dAtA[i:], m.FunctionNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.FunctionNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ModuleName) > 0 {
		i -= len(m.ModuleName)
		copy(dAtA[i:], m.ModuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModuleName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModuleAddress) > 0 {
		i -= len(m.ModuleAddress)
		copy(dAtA[i:], m.ModuleAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModuleAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.BaseMinGasPrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.ContractSharedRevenueRatio.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.ScriptEnabled {
		n += 2
	}
	if len(m.AllowedPublishers) > 0 {
		for _, s := range m.AllowedPublishers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *RawParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.BaseMinGasPrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.ContractSharedRevenueRatio.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.ScriptEnabled {
		n += 2
	}
	return n
}

func (m *Module) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Abi)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RawBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UpgradePolicy != 0 {
		n += 1 + sovTypes(uint64(m.UpgradePolicy))
	}
	return n
}

func (m *Checksum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StructTag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MoveResource)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RawBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValueType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TableEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KeyBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValueBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *UpgradePolicyProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovTypes(uint64(m.Policy))
	}
	return n
}

func (m *DexPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetadataQuote)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MetadataLP)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ExecuteAuthorizationItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModuleAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.FunctionNames) > 0 {
		for _, s := range m.FunctionNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMinGasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMinGasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSharedRevenueRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractSharedRevenueRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScriptEnabled = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedPublishers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedPublishers = append(m.AllowedPublishers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMinGasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMinGasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSharedRevenueRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractSharedRevenueRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScriptEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ScriptEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Module) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Module: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Module: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradePolicy", wireType)
			}
			m.UpgradePolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradePolicy |= UpgradePolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Checksum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Checksum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Checksum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = append(m.Checksum[:0], dAtA[iNdEx:postIndex]...)
			if m.Checksum == nil {
				m.Checksum = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StructTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StructTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MoveResource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBytes = append(m.KeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBytes == nil {
				m.KeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBytes = append(m.ValueBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBytes == nil {
				m.ValueBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradePolicyProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradePolicyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradePolicyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= UpgradePolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DexPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DexPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DexPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataLP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataLP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteAuthorizationItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteAuthorizationItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteAuthorizationItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FunctionNames = append(m.FunctionNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
