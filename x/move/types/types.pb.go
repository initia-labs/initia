// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: initia/move/v1/types.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UpgradePolicy
//   - `arbitrary`
//     Whether unconditional code upgrade with no compatibility check is allowed. This
//     publication mode should only be used for modules which aren't shared with user others.
//     The developer is responsible for not breaking memory layout of any resources he already
//     stored on chain.
//   - `compatible`
//     Whether a compatibility check should be performed for upgrades. The check only passes if
//     a new module has (a) the same public functions (b) for existing resources, no layout change.
//   - `immutable`
//     Whether the modules in the package are immutable and cannot be upgraded.
type UpgradePolicy int32

const (
	UpgradePolicy_ARBITRARY  UpgradePolicy = 0
	UpgradePolicy_COMPATIBLE UpgradePolicy = 1
	UpgradePolicy_IMMUTABLE  UpgradePolicy = 2
)

var UpgradePolicy_name = map[int32]string{
	0: "ARBITRARY",
	1: "COMPATIBLE",
	2: "IMMUTABLE",
}

var UpgradePolicy_value = map[string]int32{
	"ARBITRARY":  0,
	"COMPATIBLE": 1,
	"IMMUTABLE":  2,
}

func (x UpgradePolicy) String() string {
	return proto.EnumName(UpgradePolicy_name, int32(x))
}

func (UpgradePolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{0}
}

// Params defines the set of move parameters.
type Params struct {
	MaxModuleSize    uint64                                 `protobuf:"varint,1,opt,name=max_module_size,json=maxModuleSize,proto3" json:"max_module_size,omitempty"`
	BaseDenom        string                                 `protobuf:"bytes,2,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	BaseMinGasPrice  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=base_min_gas_price,json=baseMinGasPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"base_min_gas_price" yaml:"base_min_gas_price"`
	ArbitraryEnabled bool                                   `protobuf:"varint,4,opt,name=arbitrary_enabled,json=arbitraryEnabled,proto3" json:"arbitrary_enabled,omitempty"`
	// CSR: Percentage of fees distributed to developers
	ContractSharedRevenueRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=contract_shared_revenue_ratio,json=contractSharedRevenueRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"contract_shared_revenue_ratio" yaml:"contract_shared_revenue_ratio"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

// RawParams defines the raw params to store.
type RawParams struct {
	MaxModuleSize   uint64                                 `protobuf:"varint,1,opt,name=max_module_size,json=maxModuleSize,proto3" json:"max_module_size,omitempty"`
	BaseDenom       string                                 `protobuf:"bytes,2,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	BaseMinGasPrice github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=base_min_gas_price,json=baseMinGasPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"base_min_gas_price" yaml:"base_min_gas_price"`
	// CSR: Percentage of fees distributed to developers
	ContractSharedRevenueRatio github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=contract_shared_revenue_ratio,json=contractSharedRevenueRatio,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"contract_shared_revenue_ratio" yaml:"contract_shared_revenue_ratio"`
}

func (m *RawParams) Reset()         { *m = RawParams{} }
func (m *RawParams) String() string { return proto.CompactTextString(m) }
func (*RawParams) ProtoMessage()    {}
func (*RawParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{1}
}
func (m *RawParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawParams.Merge(m, src)
}
func (m *RawParams) XXX_Size() int {
	return m.Size()
}
func (m *RawParams) XXX_DiscardUnknown() {
	xxx_messageInfo_RawParams.DiscardUnknown(m)
}

var xxx_messageInfo_RawParams proto.InternalMessageInfo

// Resource is data for the stored move resource
// ex) 0000000000000000000000000000000000000002/1/0x1::BasicCoin::Coin<0x1::BasicCoin::Initia>
type Resource struct {
	Address      string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	StructTag    string `protobuf:"bytes,2,opt,name=struct_tag,json=structTag,proto3" json:"struct_tag,omitempty"`
	MoveResource string `protobuf:"bytes,3,opt,name=move_resource,json=moveResource,proto3" json:"move_resource,omitempty"`
	RawBytes     []byte `protobuf:"bytes,4,opt,name=raw_bytes,json=rawBytes,proto3" json:"raw_bytes,omitempty"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{2}
}
func (m *Resource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return m.Size()
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

// Module is data for the uploaded contract move code
// ex) 0000000000000000000000000000000000000001/0/BasicCoin
type Module struct {
	Address       string        `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	ModuleName    string        `protobuf:"bytes,2,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	Abi           string        `protobuf:"bytes,3,opt,name=abi,proto3" json:"abi,omitempty"`
	RawBytes      []byte        `protobuf:"bytes,4,opt,name=raw_bytes,json=rawBytes,proto3" json:"raw_bytes,omitempty"`
	UpgradePolicy UpgradePolicy `protobuf:"varint,5,opt,name=upgrade_policy,json=upgradePolicy,proto3,enum=initia.move.v1.UpgradePolicy" json:"upgrade_policy,omitempty"`
}

func (m *Module) Reset()         { *m = Module{} }
func (m *Module) String() string { return proto.CompactTextString(m) }
func (*Module) ProtoMessage()    {}
func (*Module) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{3}
}
func (m *Module) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Module) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Module.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Module) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Module.Merge(m, src)
}
func (m *Module) XXX_Size() int {
	return m.Size()
}
func (m *Module) XXX_DiscardUnknown() {
	xxx_messageInfo_Module.DiscardUnknown(m)
}

var xxx_messageInfo_Module proto.InternalMessageInfo

// TableInfo is data stored under Table address
type TableInfo struct {
	Address   string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	KeyType   string `protobuf:"bytes,2,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	ValueType string `protobuf:"bytes,3,opt,name=value_type,json=valueType,proto3" json:"value_type,omitempty"`
}

func (m *TableInfo) Reset()         { *m = TableInfo{} }
func (m *TableInfo) String() string { return proto.CompactTextString(m) }
func (*TableInfo) ProtoMessage()    {}
func (*TableInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{4}
}
func (m *TableInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableInfo.Merge(m, src)
}
func (m *TableInfo) XXX_Size() int {
	return m.Size()
}
func (m *TableInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TableInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TableInfo proto.InternalMessageInfo

// TableEntry is data stored under Table address and the key bytes
type TableEntry struct {
	Address    string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Key        string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value      string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	KeyBytes   []byte `protobuf:"bytes,4,opt,name=key_bytes,json=keyBytes,proto3" json:"key_bytes,omitempty"`
	ValueBytes []byte `protobuf:"bytes,5,opt,name=value_bytes,json=valueBytes,proto3" json:"value_bytes,omitempty"`
}

func (m *TableEntry) Reset()         { *m = TableEntry{} }
func (m *TableEntry) String() string { return proto.CompactTextString(m) }
func (*TableEntry) ProtoMessage()    {}
func (*TableEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{5}
}
func (m *TableEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableEntry.Merge(m, src)
}
func (m *TableEntry) XXX_Size() int {
	return m.Size()
}
func (m *TableEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_TableEntry.DiscardUnknown(m)
}

var xxx_messageInfo_TableEntry proto.InternalMessageInfo

// proto wrapper to store the value
type UpgradePolicyProto struct {
	Policy UpgradePolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=initia.move.v1.UpgradePolicy" json:"policy,omitempty"`
}

func (m *UpgradePolicyProto) Reset()         { *m = UpgradePolicyProto{} }
func (m *UpgradePolicyProto) String() string { return proto.CompactTextString(m) }
func (*UpgradePolicyProto) ProtoMessage()    {}
func (*UpgradePolicyProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{6}
}
func (m *UpgradePolicyProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradePolicyProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradePolicyProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradePolicyProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradePolicyProto.Merge(m, src)
}
func (m *UpgradePolicyProto) XXX_Size() int {
	return m.Size()
}
func (m *UpgradePolicyProto) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradePolicyProto.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradePolicyProto proto.InternalMessageInfo

// DexPair contains coin metdata address
// std::dex::Pool and std::dex::Config resources.
type DexPair struct {
	MetadataQuote string `protobuf:"bytes,1,opt,name=metadata_quote,json=metadataQuote,proto3" json:"metadata_quote,omitempty"`
	MetadataLP    string `protobuf:"bytes,2,opt,name=metadata_lp,json=metadataLp,proto3" json:"metadata_lp,omitempty"`
}

func (m *DexPair) Reset()         { *m = DexPair{} }
func (m *DexPair) String() string { return proto.CompactTextString(m) }
func (*DexPair) ProtoMessage()    {}
func (*DexPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{7}
}
func (m *DexPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DexPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DexPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DexPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DexPair.Merge(m, src)
}
func (m *DexPair) XXX_Size() int {
	return m.Size()
}
func (m *DexPair) XXX_DiscardUnknown() {
	xxx_messageInfo_DexPair.DiscardUnknown(m)
}

var xxx_messageInfo_DexPair proto.InternalMessageInfo

// ExecuteAuthorizationItem is the information for granting module execution
type ExecuteAuthorizationItem struct {
	// ModuleAddr is the address of the module deployer
	ModuleAddress string `protobuf:"bytes,1,opt,name=module_address,json=moduleAddress,proto3" json:"module_address,omitempty"`
	// ModuleName is the names of module to execute
	ModuleName string `protobuf:"bytes,2,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	// FunctionName is the name of function to execute with wildcard '*' support
	FunctionNames []string `protobuf:"bytes,3,rep,name=function_names,json=functionNames,proto3" json:"function_names,omitempty"`
}

func (m *ExecuteAuthorizationItem) Reset()         { *m = ExecuteAuthorizationItem{} }
func (m *ExecuteAuthorizationItem) String() string { return proto.CompactTextString(m) }
func (*ExecuteAuthorizationItem) ProtoMessage()    {}
func (*ExecuteAuthorizationItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_5ab4b0783858a3a5, []int{8}
}
func (m *ExecuteAuthorizationItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteAuthorizationItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteAuthorizationItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteAuthorizationItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteAuthorizationItem.Merge(m, src)
}
func (m *ExecuteAuthorizationItem) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteAuthorizationItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteAuthorizationItem.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteAuthorizationItem proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("initia.move.v1.UpgradePolicy", UpgradePolicy_name, UpgradePolicy_value)
	proto.RegisterType((*Params)(nil), "initia.move.v1.Params")
	proto.RegisterType((*RawParams)(nil), "initia.move.v1.RawParams")
	proto.RegisterType((*Resource)(nil), "initia.move.v1.Resource")
	proto.RegisterType((*Module)(nil), "initia.move.v1.Module")
	proto.RegisterType((*TableInfo)(nil), "initia.move.v1.TableInfo")
	proto.RegisterType((*TableEntry)(nil), "initia.move.v1.TableEntry")
	proto.RegisterType((*UpgradePolicyProto)(nil), "initia.move.v1.UpgradePolicyProto")
	proto.RegisterType((*DexPair)(nil), "initia.move.v1.DexPair")
	proto.RegisterType((*ExecuteAuthorizationItem)(nil), "initia.move.v1.ExecuteAuthorizationItem")
}

func init() { proto.RegisterFile("initia/move/v1/types.proto", fileDescriptor_5ab4b0783858a3a5) }

var fileDescriptor_5ab4b0783858a3a5 = []byte{
	// 862 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x55, 0xcf, 0x6f, 0x1b, 0x45,
	0x18, 0xf5, 0xc4, 0xf9, 0xb5, 0x5f, 0x6a, 0x37, 0x1d, 0xf5, 0xb0, 0x0d, 0x8a, 0x37, 0x5a, 0xa0,
	0x8a, 0x52, 0xd5, 0x56, 0x41, 0x5c, 0x2a, 0x71, 0xb0, 0x49, 0x84, 0x2c, 0x62, 0x30, 0x53, 0xf7,
	0x00, 0x1c, 0x56, 0xe3, 0xdd, 0xa9, 0xb3, 0xb2, 0x77, 0xc7, 0xcc, 0xcc, 0x3a, 0xde, 0x48, 0x1c,
	0xb9, 0x20, 0x24, 0x38, 0x72, 0x42, 0x3d, 0xf6, 0xd8, 0x13, 0xe2, 0x4f, 0xc8, 0xb1, 0x47, 0xc4,
	0xc1, 0x02, 0xe7, 0x50, 0xce, 0xfd, 0x0b, 0xd0, 0xcc, 0xac, 0xa3, 0x5a, 0x48, 0x56, 0xb9, 0x21,
	0x2e, 0xc9, 0xcc, 0x7b, 0x4f, 0xdf, 0xbc, 0x79, 0xdf, 0xe7, 0x59, 0xd8, 0x8b, 0xd3, 0x58, 0xc5,
	0xb4, 0x91, 0xf0, 0x09, 0x6b, 0x4c, 0x1e, 0x34, 0x54, 0x3e, 0x66, 0xb2, 0x3e, 0x16, 0x5c, 0x71,
	0x5c, 0xb5, 0x5c, 0x5d, 0x73, 0xf5, 0xc9, 0x83, 0xbd, 0x5b, 0x34, 0x89, 0x53, 0xde, 0x30, 0x7f,
	0xad, 0x64, 0xef, 0xf6, 0x80, 0x0f, 0xb8, 0x59, 0x36, 0xf4, 0xca, 0xa2, 0xfe, 0x2f, 0x65, 0xd8,
	0xec, 0x52, 0x41, 0x13, 0x89, 0xef, 0xc2, 0xcd, 0x84, 0x4e, 0x83, 0x84, 0x47, 0xd9, 0x88, 0x05,
	0x32, 0xbe, 0x60, 0x2e, 0x3a, 0x40, 0x87, 0xeb, 0xa4, 0x92, 0xd0, 0x69, 0xc7, 0xa0, 0x8f, 0xe2,
	0x0b, 0x86, 0xf7, 0x01, 0xfa, 0x54, 0xb2, 0x20, 0x62, 0x29, 0x4f, 0xdc, 0xb5, 0x03, 0x74, 0xe8,
	0x10, 0x47, 0x23, 0xc7, 0x1a, 0xc0, 0xdf, 0x00, 0x36, 0x74, 0x12, 0xa7, 0xc1, 0x80, 0xca, 0x60,
	0x2c, 0xe2, 0x90, 0xb9, 0x65, 0x2d, 0x6b, 0x75, 0x2f, 0x67, 0x5e, 0xe9, 0xf7, 0x99, 0x77, 0x77,
	0x10, 0xab, 0xb3, 0xac, 0x5f, 0x0f, 0x79, 0xd2, 0x08, 0xb9, 0x4c, 0xb8, 0x2c, 0xfe, 0xdd, 0x97,
	0xd1, 0xb0, 0xb8, 0xd8, 0x31, 0x0b, 0x5f, 0xcd, 0xbc, 0x3b, 0x39, 0x4d, 0x46, 0x0f, 0xfd, 0x7f,
	0x56, 0xf4, 0x9f, 0xbd, 0x7c, 0x7e, 0x84, 0xc8, 0x4d, 0xcd, 0x74, 0xe2, 0xf4, 0x63, 0x2a, 0xbb,
	0x1a, 0xc6, 0xf7, 0xe0, 0x16, 0x15, 0xfd, 0x58, 0x09, 0x2a, 0xf2, 0x80, 0xa5, 0xb4, 0x3f, 0x62,
	0x91, 0xbb, 0x7e, 0x80, 0x0e, 0xb7, 0xc9, 0xee, 0x35, 0x71, 0x62, 0x71, 0xfc, 0x33, 0x82, 0xfd,
	0x90, 0xa7, 0x4a, 0xd0, 0x50, 0x05, 0xf2, 0x8c, 0x0a, 0x16, 0x05, 0x82, 0x4d, 0x58, 0x9a, 0xb1,
	0x40, 0x50, 0x15, 0x73, 0x77, 0xc3, 0xf8, 0xfe, 0xea, 0x5f, 0xfb, 0x7e, 0xc7, 0xfa, 0x5e, 0x59,
	0xbc, 0xb8, 0xc2, 0xde, 0x42, 0xf4, 0xc8, 0x68, 0x88, 0x95, 0x10, 0xad, 0x78, 0xe8, 0xfe, 0xf4,
	0xd4, 0x2b, 0xfd, 0xf5, 0xd4, 0x43, 0xdf, 0xbd, 0x7c, 0x7e, 0xb4, 0x63, 0x3a, 0x6f, 0xbb, 0xe5,
	0xbf, 0x5a, 0x03, 0x87, 0xd0, 0xf3, 0xff, 0x55, 0xef, 0xfe, 0xeb, 0xed, 0xf0, 0xbf, 0x45, 0xb0,
	0x4d, 0x98, 0xe4, 0x99, 0x08, 0x19, 0x76, 0x61, 0x8b, 0x46, 0x91, 0x60, 0x52, 0x9a, 0xac, 0x1d,
	0xb2, 0xd8, 0xea, 0x94, 0xa5, 0x12, 0x59, 0xa8, 0x02, 0x45, 0x07, 0x8b, 0x94, 0x2d, 0xd2, 0xa3,
	0x03, 0xfc, 0x36, 0x54, 0x74, 0x27, 0x03, 0x51, 0x54, 0xb2, 0x01, 0x93, 0x1b, 0x1a, 0xbc, 0xae,
	0xfe, 0x16, 0x38, 0x82, 0x9e, 0x07, 0xfd, 0x5c, 0x31, 0x69, 0xe6, 0xf7, 0x06, 0xd9, 0x16, 0xf4,
	0xbc, 0xa5, 0xf7, 0xfe, 0xaf, 0x08, 0x36, 0x6d, 0x57, 0x57, 0xb8, 0xf0, 0x60, 0xa7, 0x98, 0x87,
	0x94, 0x26, 0xac, 0xb0, 0x01, 0x16, 0xfa, 0x94, 0x26, 0x0c, 0xef, 0x42, 0x99, 0xf6, 0xe3, 0xe2,
	0x74, 0xbd, 0x5c, 0x79, 0x28, 0x3e, 0x86, 0x6a, 0x36, 0x1e, 0x08, 0x1a, 0xb1, 0x60, 0xcc, 0x47,
	0x71, 0x98, 0x9b, 0x6e, 0x54, 0xdf, 0xdb, 0xaf, 0x2f, 0x3f, 0x3e, 0xf5, 0xc7, 0x56, 0xd5, 0x35,
	0x22, 0x52, 0xc9, 0x5e, 0xdf, 0xfa, 0x01, 0x38, 0x3d, 0xfd, 0xe3, 0x6b, 0xa7, 0x4f, 0xf8, 0x0a,
	0xf3, 0x77, 0x60, 0x7b, 0xc8, 0xf2, 0x40, 0xf7, 0xb0, 0x70, 0xbe, 0x35, 0x64, 0x79, 0x2f, 0x1f,
	0x9b, 0x19, 0x9e, 0xd0, 0x51, 0xc6, 0x2c, 0x69, 0xdd, 0x3b, 0x06, 0xd1, 0xb4, 0xff, 0x3d, 0x02,
	0x30, 0x27, 0x9c, 0xa4, 0x4a, 0xe4, 0x2b, 0x8e, 0xd8, 0x85, 0xf2, 0x90, 0xe5, 0x45, 0x75, 0xbd,
	0xc4, 0xb7, 0x61, 0xc3, 0xd4, 0x29, 0x8a, 0xda, 0x8d, 0x0e, 0x45, 0x5b, 0x59, 0x0a, 0x65, 0xc8,
	0x72, 0x1b, 0x8a, 0x07, 0x3b, 0xd6, 0x8c, 0xa5, 0x37, 0x0c, 0x6d, 0xfd, 0xd9, 0x56, 0x7d, 0x02,
	0x78, 0x29, 0x8f, 0xae, 0x79, 0xaf, 0x3f, 0x80, 0xcd, 0x22, 0x43, 0xf4, 0x26, 0x19, 0x16, 0x62,
	0x9f, 0xc2, 0xd6, 0x31, 0x9b, 0x76, 0x69, 0x2c, 0xf0, 0xbb, 0x50, 0x4d, 0x98, 0xa2, 0x11, 0x55,
	0x34, 0xf8, 0x3a, 0xe3, 0x8a, 0x15, 0xd7, 0xab, 0x2c, 0xd0, 0xcf, 0x35, 0x88, 0x1b, 0xb0, 0x73,
	0x2d, 0x1b, 0x8d, 0xed, 0x65, 0x5b, 0xd5, 0xf9, 0xcc, 0x83, 0x4e, 0x01, 0x9f, 0x76, 0x09, 0x2c,
	0x24, 0xa7, 0x63, 0xff, 0x07, 0x04, 0xee, 0xc9, 0x94, 0x85, 0x99, 0x62, 0xcd, 0x4c, 0x9d, 0x71,
	0x11, 0x5f, 0xe8, 0xd1, 0x4f, 0xdb, 0x8a, 0x25, 0xe6, 0x50, 0x3b, 0x52, 0xcb, 0x99, 0x56, 0x2c,
	0xda, 0x7c, 0xd3, 0xc9, 0xbb, 0x07, 0xd5, 0x27, 0x59, 0x1a, 0xea, 0xba, 0x46, 0x22, 0xdd, 0xf2,
	0x41, 0xf9, 0xd0, 0x69, 0xad, 0x5f, 0xce, 0x3c, 0x44, 0x2a, 0x0b, 0x4e, 0x6b, 0xe5, 0xd1, 0x87,
	0x50, 0x59, 0x4a, 0x03, 0x57, 0xc0, 0x69, 0x92, 0x56, 0xbb, 0x47, 0x9a, 0xe4, 0x8b, 0xdd, 0x12,
	0xae, 0x02, 0x7c, 0xf4, 0x59, 0xa7, 0xdb, 0xec, 0xb5, 0x5b, 0xa7, 0x27, 0xbb, 0x48, 0xd3, 0xed,
	0x4e, 0xe7, 0x71, 0xaf, 0xa9, 0xb7, 0x6b, 0xad, 0xd3, 0xcb, 0x3f, 0x6b, 0xa5, 0x67, 0xf3, 0x1a,
	0xba, 0x9c, 0xd7, 0xd0, 0x8b, 0x79, 0x0d, 0xfd, 0x31, 0xaf, 0xa1, 0x1f, 0xaf, 0x6a, 0xa5, 0x17,
	0x57, 0xb5, 0xd2, 0x6f, 0x57, 0xb5, 0xd2, 0x97, 0x47, 0xaf, 0x3d, 0x23, 0xb6, 0x0d, 0xf7, 0x47,
	0xb4, 0x2f, 0x8b, 0x75, 0x63, 0x6a, 0xbf, 0xb8, 0xe6, 0x39, 0xe9, 0x6f, 0x9a, 0xcf, 0xe6, 0xfb,
	0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x19, 0x19, 0xce, 0xad, 0x8d, 0x07, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxModuleSize != that1.MaxModuleSize {
		return false
	}
	if this.BaseDenom != that1.BaseDenom {
		return false
	}
	if !this.BaseMinGasPrice.Equal(that1.BaseMinGasPrice) {
		return false
	}
	if this.ArbitraryEnabled != that1.ArbitraryEnabled {
		return false
	}
	if !this.ContractSharedRevenueRatio.Equal(that1.ContractSharedRevenueRatio) {
		return false
	}
	return true
}
func (this *RawParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RawParams)
	if !ok {
		that2, ok := that.(RawParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxModuleSize != that1.MaxModuleSize {
		return false
	}
	if this.BaseDenom != that1.BaseDenom {
		return false
	}
	if !this.BaseMinGasPrice.Equal(that1.BaseMinGasPrice) {
		return false
	}
	if !this.ContractSharedRevenueRatio.Equal(that1.ContractSharedRevenueRatio) {
		return false
	}
	return true
}
func (this *Resource) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Resource)
	if !ok {
		that2, ok := that.(Resource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.StructTag != that1.StructTag {
		return false
	}
	if this.MoveResource != that1.MoveResource {
		return false
	}
	if !bytes.Equal(this.RawBytes, that1.RawBytes) {
		return false
	}
	return true
}
func (this *Module) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Module)
	if !ok {
		that2, ok := that.(Module)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.ModuleName != that1.ModuleName {
		return false
	}
	if this.Abi != that1.Abi {
		return false
	}
	if !bytes.Equal(this.RawBytes, that1.RawBytes) {
		return false
	}
	if this.UpgradePolicy != that1.UpgradePolicy {
		return false
	}
	return true
}
func (this *TableInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableInfo)
	if !ok {
		that2, ok := that.(TableInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if this.ValueType != that1.ValueType {
		return false
	}
	return true
}
func (this *TableEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TableEntry)
	if !ok {
		that2, ok := that.(TableEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if !bytes.Equal(this.KeyBytes, that1.KeyBytes) {
		return false
	}
	if !bytes.Equal(this.ValueBytes, that1.ValueBytes) {
		return false
	}
	return true
}
func (this *UpgradePolicyProto) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpgradePolicyProto)
	if !ok {
		that2, ok := that.(UpgradePolicyProto)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Policy != that1.Policy {
		return false
	}
	return true
}
func (this *DexPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DexPair)
	if !ok {
		that2, ok := that.(DexPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MetadataQuote != that1.MetadataQuote {
		return false
	}
	if this.MetadataLP != that1.MetadataLP {
		return false
	}
	return true
}
func (this *ExecuteAuthorizationItem) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecuteAuthorizationItem)
	if !ok {
		that2, ok := that.(ExecuteAuthorizationItem)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ModuleAddress != that1.ModuleAddress {
		return false
	}
	if this.ModuleName != that1.ModuleName {
		return false
	}
	if len(this.FunctionNames) != len(that1.FunctionNames) {
		return false
	}
	for i := range this.FunctionNames {
		if this.FunctionNames[i] != that1.FunctionNames[i] {
			return false
		}
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ContractSharedRevenueRatio.Size()
		i -= size
		if _, err := m.ContractSharedRevenueRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.ArbitraryEnabled {
		i--
		if m.ArbitraryEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	{
		size := m.BaseMinGasPrice.Size()
		i -= size
		if _, err := m.BaseMinGasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x12
	}
	if m.MaxModuleSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxModuleSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ContractSharedRevenueRatio.Size()
		i -= size
		if _, err := m.ContractSharedRevenueRatio.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.BaseMinGasPrice.Size()
		i -= size
		if _, err := m.BaseMinGasPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x12
	}
	if m.MaxModuleSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxModuleSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Resource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RawBytes) > 0 {
		i -= len(m.RawBytes)
		copy(dAtA[i:], m.RawBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RawBytes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MoveResource) > 0 {
		i -= len(m.MoveResource)
		copy(dAtA[i:], m.MoveResource)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MoveResource)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StructTag) > 0 {
		i -= len(m.StructTag)
		copy(dAtA[i:], m.StructTag)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StructTag)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Module) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Module) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Module) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpgradePolicy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpgradePolicy))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RawBytes) > 0 {
		i -= len(m.RawBytes)
		copy(dAtA[i:], m.RawBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RawBytes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Abi) > 0 {
		i -= len(m.Abi)
		copy(dAtA[i:], m.Abi)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Abi)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModuleName) > 0 {
		i -= len(m.ModuleName)
		copy(dAtA[i:], m.ModuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModuleName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueType) > 0 {
		i -= len(m.ValueType)
		copy(dAtA[i:], m.ValueType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValueType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TableEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValueBytes) > 0 {
		i -= len(m.ValueBytes)
		copy(dAtA[i:], m.ValueBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValueBytes)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyBytes) > 0 {
		i -= len(m.KeyBytes)
		copy(dAtA[i:], m.KeyBytes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyBytes)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradePolicyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradePolicyProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradePolicyProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Policy != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DexPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DexPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DexPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MetadataLP) > 0 {
		i -= len(m.MetadataLP)
		copy(dAtA[i:], m.MetadataLP)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MetadataLP)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MetadataQuote) > 0 {
		i -= len(m.MetadataQuote)
		copy(dAtA[i:], m.MetadataQuote)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MetadataQuote)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteAuthorizationItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteAuthorizationItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteAuthorizationItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FunctionNames) > 0 {
		for iNdEx := len(m.FunctionNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FunctionNames[iNdEx])
			copy(dAtA[i:], m.FunctionNames[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.FunctionNames[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ModuleName) > 0 {
		i -= len(m.ModuleName)
		copy(dAtA[i:], m.ModuleName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModuleName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModuleAddress) > 0 {
		i -= len(m.ModuleAddress)
		copy(dAtA[i:], m.ModuleAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModuleAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxModuleSize != 0 {
		n += 1 + sovTypes(uint64(m.MaxModuleSize))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.BaseMinGasPrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.ArbitraryEnabled {
		n += 2
	}
	l = m.ContractSharedRevenueRatio.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *RawParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxModuleSize != 0 {
		n += 1 + sovTypes(uint64(m.MaxModuleSize))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.BaseMinGasPrice.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.ContractSharedRevenueRatio.Size()
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StructTag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MoveResource)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RawBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Module) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Abi)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RawBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UpgradePolicy != 0 {
		n += 1 + sovTypes(uint64(m.UpgradePolicy))
	}
	return n
}

func (m *TableInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValueType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TableEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KeyBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValueBytes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *UpgradePolicyProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovTypes(uint64(m.Policy))
	}
	return n
}

func (m *DexPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MetadataQuote)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MetadataLP)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ExecuteAuthorizationItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModuleAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModuleName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.FunctionNames) > 0 {
		for _, s := range m.FunctionNames {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxModuleSize", wireType)
			}
			m.MaxModuleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxModuleSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMinGasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMinGasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArbitraryEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ArbitraryEnabled = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSharedRevenueRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractSharedRevenueRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxModuleSize", wireType)
			}
			m.MaxModuleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxModuleSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMinGasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BaseMinGasPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSharedRevenueRatio", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContractSharedRevenueRatio.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StructTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StructTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MoveResource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Module) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Module: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Module: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawBytes = append(m.RawBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RawBytes == nil {
				m.RawBytes = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradePolicy", wireType)
			}
			m.UpgradePolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpgradePolicy |= UpgradePolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBytes = append(m.KeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBytes == nil {
				m.KeyBytes = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueBytes = append(m.ValueBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ValueBytes == nil {
				m.ValueBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradePolicyProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradePolicyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradePolicyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= UpgradePolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DexPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DexPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DexPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataQuote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataQuote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataLP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataLP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteAuthorizationItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteAuthorizationItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteAuthorizationItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModuleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModuleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FunctionNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FunctionNames = append(m.FunctionNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
